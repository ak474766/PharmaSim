{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/PharmaSim/src/lib/firebase.ts"],"sourcesContent":["import { initializeApp, getApps } from 'firebase/app';\nimport { getAuth, GoogleAuthProvider } from 'firebase/auth';\nimport { getFirestore } from 'firebase/firestore';\nimport { getStorage } from 'firebase/storage';\n\nconst firebaseConfig = {\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID\n};\n\nconst app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];\nexport const auth = getAuth(app);\nexport const db = getFirestore(app);\nexport const storage = getStorage(app);\nexport const googleProvider = new GoogleAuthProvider();\nexport default app;\n"],"names":[],"mappings":";;;;;;;;;;;;AAMY;AANZ;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAEA,MAAM,iBAAiB;IACnB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AACT;AAEA,MAAM,MAAM,IAAA,8KAAO,IAAG,MAAM,KAAK,IAAI,IAAA,oLAAa,EAAC,kBAAkB,IAAA,8KAAO,GAAE,CAAC,EAAE;AAC1E,MAAM,OAAO,IAAA,oMAAO,EAAC;AACrB,MAAM,KAAK,IAAA,kLAAY,EAAC;AACxB,MAAM,UAAU,IAAA,8KAAU,EAAC;AAC3B,MAAM,iBAAiB,IAAI,+MAAkB;uCACrC"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/PharmaSim/src/lib/userService.ts"],"sourcesContent":["\nimport { db } from './firebase';\nimport { doc, getDoc, setDoc, updateDoc, collection, query, orderBy, limit, getDocs } from 'firebase/firestore';\n\nexport interface Quest {\n    id: string;\n    title: string;\n    description: string;\n    progress: number;\n    total: number;\n    completed: boolean;\n    type: 'build_molecule' | 'earn_xp';\n}\n\nexport interface Achievement {\n    id: string;\n    title: string;\n    description: string;\n    icon: string;\n    unlockedAt: number; // Timestamp\n}\n\nexport interface UserProfile {\n    uid: string;\n    displayName: string;\n    email: string;\n    xp: number;\n    level: number;\n    reputation: number;\n    moleculesDiscovered: number;\n    dailyQuests?: Quest[];\n    lastLogin?: number;\n    achievements?: Achievement[];\n    topicMastery?: Record<string, number>;\n}\n\nconst QUEST_TEMPLATES: Omit<Quest, 'progress' | 'completed'>[] = [\n    { id: 'q1', title: 'Synthesis Master', description: 'Build 3 Molecules', total: 3, type: 'build_molecule' },\n    { id: 'q2', title: 'Lab Rat', description: 'Earn 500 XP', total: 500, type: 'earn_xp' },\n    { id: 'q3', title: 'Daily Discovery', description: 'Build 1 Complex Molecule', total: 1, type: 'build_molecule' }\n];\n\nexport const UserService = {\n    // Get user profile or create if not exists\n    async getProfile(uid: string, email: string, displayName: string): Promise<UserProfile> {\n        const docRef = doc(db, 'users', uid);\n        const docSnap = await getDoc(docRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data() as UserProfile;\n            // Check for daily quest reset\n            const now = Date.now();\n            const oneDay = 24 * 60 * 60 * 1000;\n            if (!data.lastLogin || (now - data.lastLogin) > oneDay || !data.dailyQuests) {\n                // Reset quests\n                const newQuests = QUEST_TEMPLATES.slice(0, 2).map(q => ({ ...q, progress: 0, completed: false })); // Pick first 2 for now\n                await updateDoc(docRef, { dailyQuests: newQuests, lastLogin: now });\n                data.dailyQuests = newQuests;\n            }\n            return data;\n        } else {\n            // Create new profile\n            const newQuests = QUEST_TEMPLATES.slice(0, 2).map(q => ({ ...q, progress: 0, completed: false }));\n            const newProfile: UserProfile = {\n                uid,\n                email,\n                displayName: displayName || 'Researcher ' + uid.slice(0, 4),\n                xp: 0,\n                level: 1,\n                reputation: 100,\n                moleculesDiscovered: 0,\n                dailyQuests: newQuests,\n                lastLogin: Date.now(),\n                achievements: [],\n                topicMastery: { kinetics: 1, regulatory: 1, pharmacology: 1, chemistry: 1 }\n            };\n            await setDoc(docRef, newProfile);\n            return newProfile;\n        }\n    },\n\n    async updateDisplayName(uid: string, displayName: string) {\n        const name = displayName.trim();\n        if (!name) throw new Error('Display name cannot be empty');\n        const docRef = doc(db, 'users', uid);\n        await updateDoc(docRef, { displayName: name });\n        return name;\n    },\n\n    // Update Quest Progress\n    async updateQuestProgress(uid: string, type: string, amount: number) {\n        const docRef = doc(db, 'users', uid);\n        const docSnap = await getDoc(docRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data() as UserProfile;\n            let questsUpdated = false;\n\n            const newQuests = (data.dailyQuests || []).map(q => {\n                if (q.type === type && !q.completed) {\n                    const newProgress = Math.min(q.progress + amount, q.total);\n                    questsUpdated = true;\n                    return {\n                        ...q,\n                        progress: newProgress,\n                        completed: newProgress >= q.total\n                    };\n                }\n                return q;\n            });\n\n            if (questsUpdated) {\n                await updateDoc(docRef, { dailyQuests: newQuests });\n            }\n        }\n    },\n\n    // Unlock Achievement\n    async unlockAchievement(uid: string, achievement: Omit<Achievement, 'unlockedAt'>) {\n        const docRef = doc(db, 'users', uid);\n        const docSnap = await getDoc(docRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data() as UserProfile;\n            const existing = (data.achievements || []).find(a => a.id === achievement.id);\n            if (!existing) {\n                const newAchievement = { ...achievement, unlockedAt: Date.now() };\n                await updateDoc(docRef, {\n                    achievements: [...(data.achievements || []), newAchievement]\n                });\n                return newAchievement;\n            }\n        }\n        return null;\n    },\n\n    // Add XP and check for level up\n    async addXP(uid: string, amount: number) {\n        const docRef = doc(db, 'users', uid);\n        const docSnap = await getDoc(docRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data() as UserProfile;\n            const newXP = data.xp + amount;\n            const newLevel = Math.floor(newXP / 1000) + 1; // Simple level formula: 1000 XP per level\n\n            await updateDoc(docRef, {\n                xp: newXP,\n                level: newLevel,\n                moleculesDiscovered: data.moleculesDiscovered + 1 // Assuming 1 molecule per XP grant for now\n            });\n            return { newXP, newLevel };\n        }\n        return null;\n    },\n\n    // Get Leaderboard (Top 50 by XP)\n    async getLeaderboard(): Promise<UserProfile[]> {\n        const q = query(collection(db, 'users'), orderBy('xp', 'desc'), limit(50));\n        const querySnapshot = await getDocs(q);\n        return querySnapshot.docs.map(doc => doc.data() as UserProfile);\n    },\n\n    // Get User Rank (Client-side calculation for demo)\n    async getUserRank(uid: string): Promise<number> {\n        // Fetch specific number of top users to determine rank\n        // Note: In production you'd use a cloud function or dedicated rank field\n        const q = query(collection(db, 'users'), orderBy('xp', 'desc'), limit(100));\n        const querySnapshot = await getDocs(q);\n        const users = querySnapshot.docs.map(doc => doc.id);\n        const rank = users.indexOf(uid);\n        return rank !== -1 ? rank + 1 : 1000; // Return >100 if not in top 100\n    },\n\n    // Update Topic Mastery\n    async updateTopicMastery(uid: string, topic: string, change: number) {\n        const docRef = doc(db, 'users', uid);\n        const docSnap = await getDoc(docRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data() as UserProfile;\n            const currentMastery = data.topicMastery?.[topic] || 1;\n            const newMastery = Math.max(1, Math.min(5, currentMastery + change)); // Clamp between 1 and 5\n\n            await updateDoc(docRef, {\n                [`topicMastery.${topic}`]: newMastery\n            });\n            return newMastery;\n        }\n        return 1;\n    }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/PharmaSim/src/context/AuthContext.tsx"],"sourcesContent":["'use client';\n\n\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { onAuthStateChanged, User } from 'firebase/auth';\nimport { auth } from '@/lib/firebase';\nimport { UserService, UserProfile } from '@/lib/userService';\n\ninterface AuthContextType {\n    user: User | null;\n    profile: UserProfile | null;\n    loading: boolean;\n    refreshProfile: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType>({ user: null, profile: null, loading: true, refreshProfile: async () => { } });\n\nexport const AuthProvider = ({ children }: { children: React.ReactNode }) => {\n    const [user, setUser] = useState<User | null>(null);\n    const [profile, setProfile] = useState<UserProfile | null>(null);\n    const [loading, setLoading] = useState(true);\n\n    const fetchProfile = async (currentUser: User) => {\n        try {\n            const userProfile = await UserService.getProfile(\n                currentUser.uid,\n                currentUser.email || '',\n                currentUser.displayName || ''\n            );\n            setProfile(userProfile);\n        } catch (error) {\n            console.error(\"Error fetching profile:\", error);\n        }\n    };\n\n    useEffect(() => {\n        const unsubscribe = onAuthStateChanged(auth, async (currentUser) => {\n            setUser(currentUser);\n            if (currentUser) {\n                await fetchProfile(currentUser);\n            } else {\n                setProfile(null);\n            }\n            setLoading(false);\n        });\n\n        return () => unsubscribe();\n    }, []);\n\n    const refreshProfile = async () => {\n        if (user) {\n            await fetchProfile(user);\n        }\n    };\n\n    return (\n        <AuthContext.Provider value={{ user, profile, loading, refreshProfile }}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n"],"names":[],"mappings":";;;;;;;AAGA;AACA;AAAA;AACA;AACA;;;AANA;;;;;AAeA,MAAM,4BAAc,IAAA,8KAAa,EAAkB;IAAE,MAAM;IAAM,SAAS;IAAM,SAAS;IAAM,gBAAgB,WAAc;AAAE;AAExH,MAAM,eAAe,CAAC,EAAE,QAAQ,EAAiC;;IACpE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAc;IAC9C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAqB;IAC3D,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IAEvC,MAAM,eAAe,OAAO;QACxB,IAAI;YACA,MAAM,cAAc,MAAM,2IAAW,CAAC,UAAU,CAC5C,YAAY,GAAG,EACf,YAAY,KAAK,IAAI,IACrB,YAAY,WAAW,IAAI;YAE/B,WAAW;QACf,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,2BAA2B;QAC7C;IACJ;IAEA,IAAA,0KAAS;kCAAC;YACN,MAAM,cAAc,IAAA,+MAAkB,EAAC,iIAAI;sDAAE,OAAO;oBAChD,QAAQ;oBACR,IAAI,aAAa;wBACb,MAAM,aAAa;oBACvB,OAAO;wBACH,WAAW;oBACf;oBACA,WAAW;gBACf;;YAEA;0CAAO,IAAM;;QACjB;iCAAG,EAAE;IAEL,MAAM,iBAAiB;QACnB,IAAI,MAAM;YACN,MAAM,aAAa;QACvB;IACJ;IAEA,qBACI,6LAAC,YAAY,QAAQ;QAAC,OAAO;YAAE;YAAM;YAAS;YAAS;QAAe;kBACjE;;;;;;AAGb;GA3Ca;KAAA;AA6CN,MAAM,UAAU;;IAAM,OAAA,IAAA,2KAAU,EAAC;AAAW;IAAtC"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/PharmaSim/src/lib/ultraContextService.ts"],"sourcesContent":["/**\n * UltraContext Service\n * \n * This service provides a wrapper around the UltraContext API for managing\n * AI agent conversation contexts with automatic versioning, time-travel,\n * and persistent storage.\n * \n * @see https://ultracontext.ai/docs\n */\n\nimport { UltraContext } from 'ultracontext';\n\n// =============================================================================\n// Types & Interfaces\n// =============================================================================\n\n/** Standard message format for LLM conversations */\nexport interface UCMessage {\n    role: 'system' | 'user' | 'assistant' | 'tool';\n    content: string;\n    [key: string]: unknown; // Schema-free: allows any additional fields\n}\n\n/** Context metadata for tracking */\nexport interface UCContextMetadata {\n    userId?: string;\n    sessionId?: string;\n    feature?: 'molecule-analysis' | 'quiz' | 'clinical-trial' | 'general';\n    createdAt?: string;\n    [key: string]: unknown;\n}\n\n/** Context object returned from UltraContext */\nexport interface UCContext {\n    id: string;\n    metadata?: UCContextMetadata;\n}\n\n/** Version history entry */\nexport interface UCVersion {\n    version: number;\n    operation: 'create' | 'append' | 'update' | 'delete';\n    affected: string[] | null;\n    timestamp?: string;\n}\n\n/** Get context response */\nexport interface UCGetResponse {\n    data: UCMessage[];\n    version?: number;\n    versions?: UCVersion[];\n}\n\n// =============================================================================\n// UltraContext Client Initialization\n// =============================================================================\n\nconst API_KEY = process.env.NEXT_PUBLIC_ULTRACONTEXT_API_KEY || '';\n\n// Initialize UltraContext client\nlet ucClient: UltraContext | null = null;\n\n/**\n * Get or create the UltraContext client instance\n */\nfunction getClient(): UltraContext {\n    if (!ucClient) {\n        if (!API_KEY) {\n            console.warn('[UltraContext] API key not found. Set NEXT_PUBLIC_ULTRACONTEXT_API_KEY in .env.local');\n        }\n        ucClient = new UltraContext({ apiKey: API_KEY });\n    }\n    return ucClient;\n}\n\n// =============================================================================\n// UltraContext Service\n// =============================================================================\n\nexport const UltraContextService = {\n    /**\n     * Create a new context\n     * @param metadata - Optional metadata to attach to the context\n     * @returns The created context object with ID\n     */\n    async createContext(metadata?: UCContextMetadata): Promise<UCContext> {\n        try {\n            const uc = getClient();\n            const ctx = await uc.create({ metadata });\n            console.log('[UltraContext] Created context:', ctx.id);\n            return ctx as UCContext;\n        } catch (error) {\n            console.error('[UltraContext] Failed to create context:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Fork a context from an existing one\n     * @param fromContextId - The context ID to fork from\n     * @param version - Optional version to fork from (defaults to latest)\n     * @returns The new forked context\n     */\n    async forkContext(fromContextId: string, version?: number): Promise<UCContext> {\n        try {\n            const uc = getClient();\n            const ctx = await uc.create({\n                from: fromContextId,\n                ...(version !== undefined && { version })\n            });\n            console.log('[UltraContext] Forked context:', ctx.id, 'from:', fromContextId);\n            return ctx as UCContext;\n        } catch (error) {\n            console.error('[UltraContext] Failed to fork context:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Get a context with its messages\n     * @param contextId - The context ID to retrieve\n     * @param options - Optional parameters for retrieval\n     * @returns The context data with messages\n     */\n    async getContext(\n        contextId: string,\n        options?: {\n            version?: number;\n            at?: number;\n            before?: string;\n            history?: boolean;\n        }\n    ): Promise<UCGetResponse> {\n        try {\n            const uc = getClient();\n            const result = await uc.get(contextId, options);\n            return result as unknown as UCGetResponse;\n        } catch (error) {\n            console.error('[UltraContext] Failed to get context:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * List all contexts\n     * @returns Array of all contexts\n     */\n    async listContexts(): Promise<UCContext[]> {\n        try {\n            const uc = getClient();\n            const result = await uc.get();\n            return (result.data || []) as UCContext[];\n        } catch (error) {\n            console.error('[UltraContext] Failed to list contexts:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Append one or more messages to a context\n     * @param contextId - The context ID to append to\n     * @param messages - Single message or array of messages\n     */\n    async appendMessage(\n        contextId: string,\n        messages: UCMessage | UCMessage[]\n    ): Promise<void> {\n        try {\n            const uc = getClient();\n            await uc.append(contextId, messages);\n            console.log('[UltraContext] Appended message(s) to:', contextId);\n        } catch (error) {\n            console.error('[UltraContext] Failed to append message:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Update a message by index or ID\n     * Creates a new version automatically\n     * @param contextId - The context ID\n     * @param update - The update object with index/id and new content\n     */\n    async updateMessage(\n        contextId: string,\n        update: { index: number; content: string } | { id: string; content: string } | Array<{ index: number; content: string } | { id: string; content: string }>\n    ): Promise<void> {\n        try {\n            const uc = getClient();\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            await uc.update(contextId, update as any);\n            console.log('[UltraContext] Updated message in:', contextId);\n        } catch (error) {\n            console.error('[UltraContext] Failed to update message:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Delete a message by index or ID\n     * Creates a new version automatically\n     * @param contextId - The context ID\n     * @param target - Message index (number) or ID (string), use -1 for last message\n     */\n    async deleteMessage(\n        contextId: string,\n        target: number | string\n    ): Promise<void> {\n        try {\n            const uc = getClient();\n            await uc.delete(contextId, target);\n            console.log('[UltraContext] Deleted message from:', contextId);\n        } catch (error) {\n            console.error('[UltraContext] Failed to delete message:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Get context at a specific version (time-travel)\n     * @param contextId - The context ID\n     * @param version - The version number to retrieve\n     * @returns The context data at that version\n     */\n    async getContextAtVersion(contextId: string, version: number): Promise<UCGetResponse> {\n        return this.getContext(contextId, { version });\n    },\n\n    /**\n     * Get context with full version history\n     * @param contextId - The context ID\n     * @returns The context data with version history\n     */\n    async getContextWithHistory(contextId: string): Promise<UCGetResponse> {\n        return this.getContext(contextId, { history: true });\n    },\n\n    // =========================================================================\n    // Convenience Methods for PharmaSim Features\n    // =========================================================================\n\n    /**\n     * Create a context for molecule analysis conversations\n     * @param userId - The user's ID\n     * @param moleculeName - Name of the molecule being analyzed\n     */\n    async createMoleculeAnalysisContext(userId: string, moleculeName: string): Promise<UCContext> {\n        return this.createContext({\n            userId,\n            feature: 'molecule-analysis',\n            createdAt: new Date().toISOString(),\n            moleculeName\n        });\n    },\n\n    /**\n     * Create a context for quiz sessions\n     * @param userId - The user's ID\n     * @param topic - The quiz topic\n     */\n    async createQuizContext(userId: string, topic: string): Promise<UCContext> {\n        return this.createContext({\n            userId,\n            feature: 'quiz',\n            createdAt: new Date().toISOString(),\n            topic\n        });\n    },\n\n    /**\n     * Create a context for clinical trial simulations\n     * @param userId - The user's ID\n     * @param trialId - The trial ID\n     */\n    async createTrialContext(userId: string, trialId: string): Promise<UCContext> {\n        return this.createContext({\n            userId,\n            feature: 'clinical-trial',\n            createdAt: new Date().toISOString(),\n            trialId\n        });\n    },\n\n    /**\n     * Save a conversation exchange (user prompt + AI response)\n     * @param contextId - The context ID\n     * @param userMessage - The user's message\n     * @param assistantMessage - The AI's response\n     */\n    async saveConversationExchange(\n        contextId: string,\n        userMessage: string,\n        assistantMessage: string\n    ): Promise<void> {\n        await this.appendMessage(contextId, [\n            { role: 'user', content: userMessage },\n            { role: 'assistant', content: assistantMessage }\n        ]);\n    }\n};\n\nexport default UltraContextService;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/PharmaSim/src/context/UltraContextProvider.tsx"],"sourcesContent":["'use client';\n\n/**\n * UltraContext Provider\n * \n * React context provider for app-wide UltraContext access.\n * Manages session-based context creation and provides hooks for components.\n */\n\nimport { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { useAuth } from './AuthContext';\nimport {\n    UltraContextService,\n    UCContext,\n    UCMessage,\n    UCGetResponse\n} from '@/lib/ultraContextService';\n\n// =============================================================================\n// Types\n// =============================================================================\n\ninterface UltraContextState {\n    /** Current active context ID */\n    activeContextId: string | null;\n    /** Loading state */\n    isLoading: boolean;\n    /** Error state */\n    error: string | null;\n}\n\ninterface UltraContextValue extends UltraContextState {\n    /** Create a new general context */\n    createContext: (metadata?: Record<string, unknown>) => Promise<UCContext | null>;\n    /** Create a molecule analysis context */\n    createMoleculeContext: (moleculeName: string) => Promise<UCContext | null>;\n    /** Create a quiz context */\n    createQuizContext: (topic: string) => Promise<UCContext | null>;\n    /** Create a clinical trial context */\n    createTrialContext: (trialId: string) => Promise<UCContext | null>;\n    /** Set the active context by ID */\n    setActiveContext: (contextId: string) => void;\n    /** Get messages from the active context */\n    getMessages: () => Promise<UCMessage[]>;\n    /** Append a message to the active context */\n    appendMessage: (message: UCMessage) => Promise<void>;\n    /** Save a conversation exchange (user + assistant) */\n    saveExchange: (userMessage: string, assistantMessage: string) => Promise<void>;\n    /** Get context with history (for time-travel) */\n    getHistory: () => Promise<UCGetResponse | null>;\n    /** Clear error state */\n    clearError: () => void;\n}\n\n// =============================================================================\n// Context\n// =============================================================================\n\nconst UltraContextContext = createContext<UltraContextValue | null>(null);\n\n// =============================================================================\n// Provider Component\n// =============================================================================\n\nexport function UltraContextProvider({ children }: { children: ReactNode }) {\n    const { user } = useAuth();\n\n    const [state, setState] = useState<UltraContextState>({\n        activeContextId: null,\n        isLoading: false,\n        error: null,\n    });\n\n    // Helper to set loading state\n    const setLoading = (isLoading: boolean) => {\n        setState(prev => ({ ...prev, isLoading }));\n    };\n\n    // Helper to set error state\n    const setError = (error: string | null) => {\n        setState(prev => ({ ...prev, error, isLoading: false }));\n    };\n\n    // Clear error\n    const clearError = useCallback(() => {\n        setState(prev => ({ ...prev, error: null }));\n    }, []);\n\n    // Set active context\n    const setActiveContext = useCallback((contextId: string) => {\n        setState(prev => ({ ...prev, activeContextId: contextId }));\n    }, []);\n\n    // Create a new general context\n    const createContext = useCallback(async (metadata?: Record<string, unknown>) => {\n        setLoading(true);\n        try {\n            const ctx = await UltraContextService.createContext({\n                userId: user?.uid,\n                ...metadata\n            });\n            setState(prev => ({\n                ...prev,\n                activeContextId: ctx.id,\n                isLoading: false,\n                error: null\n            }));\n            return ctx;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : 'Failed to create context');\n            return null;\n        }\n    }, [user?.uid]);\n\n    // Create molecule analysis context\n    const createMoleculeContext = useCallback(async (moleculeName: string) => {\n        if (!user?.uid) {\n            setError('User not authenticated');\n            return null;\n        }\n        setLoading(true);\n        try {\n            const ctx = await UltraContextService.createMoleculeAnalysisContext(\n                user.uid,\n                moleculeName\n            );\n            setState(prev => ({\n                ...prev,\n                activeContextId: ctx.id,\n                isLoading: false,\n                error: null\n            }));\n            return ctx;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : 'Failed to create molecule context');\n            return null;\n        }\n    }, [user?.uid]);\n\n    // Create quiz context\n    const createQuizContext = useCallback(async (topic: string) => {\n        if (!user?.uid) {\n            setError('User not authenticated');\n            return null;\n        }\n        setLoading(true);\n        try {\n            const ctx = await UltraContextService.createQuizContext(user.uid, topic);\n            setState(prev => ({\n                ...prev,\n                activeContextId: ctx.id,\n                isLoading: false,\n                error: null\n            }));\n            return ctx;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : 'Failed to create quiz context');\n            return null;\n        }\n    }, [user?.uid]);\n\n    // Create clinical trial context\n    const createTrialContext = useCallback(async (trialId: string) => {\n        if (!user?.uid) {\n            setError('User not authenticated');\n            return null;\n        }\n        setLoading(true);\n        try {\n            const ctx = await UltraContextService.createTrialContext(user.uid, trialId);\n            setState(prev => ({\n                ...prev,\n                activeContextId: ctx.id,\n                isLoading: false,\n                error: null\n            }));\n            return ctx;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : 'Failed to create trial context');\n            return null;\n        }\n    }, [user?.uid]);\n\n    // Get messages from active context\n    const getMessages = useCallback(async (): Promise<UCMessage[]> => {\n        if (!state.activeContextId) {\n            console.warn('[UltraContext] No active context');\n            return [];\n        }\n        try {\n            const result = await UltraContextService.getContext(state.activeContextId);\n            return result.data || [];\n        } catch (err) {\n            console.error('[UltraContext] Failed to get messages:', err);\n            return [];\n        }\n    }, [state.activeContextId]);\n\n    // Append message to active context\n    const appendMessage = useCallback(async (message: UCMessage) => {\n        if (!state.activeContextId) {\n            setError('No active context');\n            return;\n        }\n        try {\n            await UltraContextService.appendMessage(state.activeContextId, message);\n        } catch (err) {\n            setError(err instanceof Error ? err.message : 'Failed to append message');\n        }\n    }, [state.activeContextId]);\n\n    // Save a conversation exchange\n    const saveExchange = useCallback(async (userMessage: string, assistantMessage: string) => {\n        if (!state.activeContextId) {\n            setError('No active context');\n            return;\n        }\n        try {\n            await UltraContextService.saveConversationExchange(\n                state.activeContextId,\n                userMessage,\n                assistantMessage\n            );\n        } catch (err) {\n            setError(err instanceof Error ? err.message : 'Failed to save exchange');\n        }\n    }, [state.activeContextId]);\n\n    // Get context with history\n    const getHistory = useCallback(async (): Promise<UCGetResponse | null> => {\n        if (!state.activeContextId) {\n            console.warn('[UltraContext] No active context');\n            return null;\n        }\n        try {\n            return await UltraContextService.getContextWithHistory(state.activeContextId);\n        } catch (err) {\n            console.error('[UltraContext] Failed to get history:', err);\n            return null;\n        }\n    }, [state.activeContextId]);\n\n    const value: UltraContextValue = {\n        ...state,\n        createContext,\n        createMoleculeContext,\n        createQuizContext,\n        createTrialContext,\n        setActiveContext,\n        getMessages,\n        appendMessage,\n        saveExchange,\n        getHistory,\n        clearError,\n    };\n\n    return (\n        <UltraContextContext.Provider value={value}>\n            {children}\n        </UltraContextContext.Provider>\n    );\n}\n\n// =============================================================================\n// Hook\n// =============================================================================\n\n/**\n * Hook to access UltraContext functionality\n * Must be used within an UltraContextProvider\n */\nexport function useUltraContext(): UltraContextValue {\n    const context = useContext(UltraContextContext);\n    if (!context) {\n        throw new Error('useUltraContext must be used within an UltraContextProvider');\n    }\n    return context;\n}\n\nexport default UltraContextProvider;\n"],"names":[],"mappings":"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"}}]
}